<!DOCTYPE html>
<meta charset="utf-8">
<script type="text/javascript" src="../lib/d3.v5.min.js"></script>

<style type="text/css">
	/* Style the lines by removing the fill and applying a stroke */
	.line {
	    fill: none;
	    stroke: #ffab00;
	    stroke-width: 3;
	}
	  
	.overlay {
	  fill: none;
	  pointer-events: all;
	}

	/* Style the dots by assigning a fill and stroke */
	.dot {
	    fill: #ffab00;
	    stroke: #fff;
	}
	  
	  .focus circle {
	  fill: none;
	  stroke: steelblue;
	}

</style>

<body>
	<div id="div1" class="svg-container"></div>
	<div id="div2" class="svg-container"></div>
	<div id="div3" class="svg-container"></div>
	<div id="div4" class="svg-container"></div>

	<script>

		// Setting margin
		const width = 960,
			  height = 500,
			  margin = 5,
			  padding = 5, 
			  adj = 30;


		//Appending first SVG element
		var svg = d3.select("div#div1").append('svg')
					.attr("preserveAspectRatio", "xMinYMin meet")
					.attr('viewbox', '-'
						+ adj + ' -'
						+ adj + ' '
						+ (width + adj*3) + " "
						+ (height + adj*3))
					.style('padding', padding)
					.style('margin', margin)
					.classed('svg-content', true);


	    function parseDate(date){
	    	format = d3.timeFormat("%y/%d/%m")
	    	// return d3.timeParse("%b %y")(date)
	    	return format(date)
   		 }
		
		const timeConv = d3.timeParse("%d-%b-%Y");
		//Load data
		// pathToData = 'boardgame_ratings.csv';

		//  d3.dsv(',',pathToData, function(d){
		//  	return{
		//  		date: d.date,
		//  		Catan_count: d['Catan_count']
		//  	};

		//  }).then(function(data){
		//  	console.log(data)
		//  })

		const dataset = d3.csv('boardgame_ratings.csv');
		dataset.then(function(data){
			var slices = data.columns.slice(1).map(function(id){
				id: id, 
				values= data.map(function(d){ //Each row is stored as a dictionary in this array
					return{
						date: d.date, //I could create arrays for each of these to their hold values
						Catan_count: d['Catan=count'],
						Dominion_count: d['Dominion=count'],
						Codenames_count: d['Codenames=count'],
						Teraforming_Mars: d['Terraforming Mars=count'],
						Gloomhaven_count: d['Gloomhaven=count'],
						Magic_count: d['Magic: The Gathering=count'],
						Monopoly_count: d['Monopoly=count']

					}
				})
			})

			console.log(values)
			// console.log(slices[Catan_count])

			// //Scales 
			// const xScale = d3.scaleTime().range([0, width]),
			// 	  yScale = d3.scaleLinear().rangeRound([height, 0]);

			// xScale.domain(d3.extent(data, function(d){
			// 	return timeConv(d.date)}));

			// yScale.domain([(0), d3.max(slices, function(c){
			// 	return d3.max(c.values, function(d){  //values is undefined
			// 		return d.Catan_count + 4;});
			// 	})
			// ]);


			// //Axes
			// const yaxis = d3.axisLeft()
			// 				.ticks((slices[0].values).length)
			// 				.scale(yScale),

			// 		xaxis = d3.axisBottom()
			// 				  .ticks(d3.timeDay.every(1))
			// 				  .tickFormat(d3.timeFormat('%b %d'))
			// 				  .scale(xScale);

			// //Lines
			// const line= d3.line()
			// 			  .x(function(d){return xScale(d.date); })
			// 			  .y(function(d){return yScale(d.measurement);});
			// let id = 0;
			// const ids = function(){
			// 		return 'line-'+id++;
			// }
		})




	





	</script>

</body>
